package priorityqueue

import (
	"testing"
	"time"

	"github.com/haru-256/ctci-6th-edition/pkg/heap"
	"github.com/stretchr/testify/require"
)

func TestNewPriorityQueue(t *testing.T) {
	tests := []struct {
		name    string
		typeName string
		setup   func() (*PriorityQueue[string], error)
		want    func(*testing.T, *PriorityQueue[string])
	}{
		{
			name:     "create string priority queue",
			typeName: "string",
			setup: func() (*PriorityQueue[string], error) {
				return NewPriorityQueue[string](PriorityCmp[string]), nil
			},
			want: func(t *testing.T, pq *PriorityQueue[string]) {
				require.NotNil(t, pq)
				require.NotNil(t, pq.heap)
				require.Equal(t, 0, pq.heap.Size())
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			pq, err := tt.setup()
			require.NoError(t, err)
			tt.want(t, pq)
		})
	}
}

func TestPriorityQueue_Insert(t *testing.T) {
	pq := NewPriorityQueue[string](PriorityCmp[string])

	// Test inserting single element
	pq.Insert("task1", 10)
	require.Equal(t, 1, pq.heap.Size())

	// Test inserting multiple elements with different priorities
	pq.Insert("task2", 5)
	pq.Insert("task3", 15)
	pq.Insert("task4", 1)

	require.Equal(t, 4, pq.heap.Size())
}

func TestPriorityQueue_Pop(t *testing.T) {
	pq := NewPriorityQueue[string](PriorityCmp[string])

	// Test pop from empty queue
	_, err := pq.Pop()
	require.Equal(t, heap.ErrorIsEmpty, err)

	// Insert elements with different priorities
	pq.Insert("low", 10)
	pq.Insert("high", 30)
	pq.Insert("medium", 20)

	// Pop should return elements in priority order (highest priority number first)
	task1, err := pq.Pop()
	require.NoError(t, err)
	require.Equal(t, "high", task1.Value)
	require.Equal(t, 30, task1.Priority)

	task2, err := pq.Pop()
	require.NoError(t, err)
	require.Equal(t, "medium", task2.Value)
	require.Equal(t, 20, task2.Priority)

	task3, err := pq.Pop()
	require.NoError(t, err)
	require.Equal(t, "low", task3.Value)
	require.Equal(t, 10, task3.Priority)

	// Queue should be empty now
	require.Equal(t, 0, pq.heap.Size())

	// Another pop should return error
	_, err = pq.Pop()
	require.Equal(t, heap.ErrorIsEmpty, err)
}

func TestPriorityQueue_DebugHeapBehavior(t *testing.T) {
	// Test the heap directly to understand its behavior
	heap := heap.NewHeap(PriorityCmp[string])

	task1 := Task[string]{Priority: 10, Value: "task1", Time: time.Now()}
	task2 := Task[string]{Priority: 5, Value: "task2", Time: time.Now()}
	task3 := Task[string]{Priority: 15, Value: "task3", Time: time.Now()}

	heap.Insert(task1)
	heap.Insert(task2)
	heap.Insert(task3)

	t.Logf("Initial heap:")
	for i, task := range heap.GetItems() {
		t.Logf("  [%d] %s priority %d", i, task.Value, task.Priority)
	}

	// Manually change priority and test UpHeap
	heap.GetItems()[1].Priority = 20 // Change task at index 1 to priority 20
	t.Logf("After changing priority at index 1 to 20:")
	for i, task := range heap.GetItems() {
		t.Logf("  [%d] %s priority %d", i, task.Value, task.Priority)
	}

	heap.UpHeap(1)
	t.Logf("After UpHeap(1):")
	for i, task := range heap.GetItems() {
		t.Logf("  [%d] %s priority %d", i, task.Value, task.Priority)
	}
}

func TestPriorityQueue_DebugBasics(t *testing.T) {
	pq := NewPriorityQueue[string](PriorityCmp[string])

	// Insert tasks
	pq.Insert("task1", 10)
	pq.Insert("task2", 5)
	pq.Insert("task3", 15)

	// Check what's at the top
	task, err := pq.Pop()
	require.NoError(t, err)
	t.Logf("First pop: %s with priority %d", task.Value, task.Priority)

	task, err = pq.Pop()
	require.NoError(t, err)
	t.Logf("Second pop: %s with priority %d", task.Value, task.Priority)

	task, err = pq.Pop()
	require.NoError(t, err)
	t.Logf("Third pop: %s with priority %d", task.Value, task.Priority)
}

func TestPriorityQueue_Update_Success(t *testing.T) {
	pq := NewPriorityQueue[string](PriorityCmp[string])

	// Insert tasks
	pq.Insert("task1", 10)
	pq.Insert("task2", 5)
	pq.Insert("task3", 15)

	// Debug: log heap contents before update
	t.Logf("Before update:")
	for i, task := range pq.heap.GetItems() {
		t.Logf("  [%d] %s priority %d", i, task.Value, task.Priority)
	}

	// Update priority of task2 to higher priority (higher number)
	err := pq.Update("task2", 20)
	require.NoError(t, err)

	// Debug: log heap contents after update
	t.Logf("After update:")
	for i, task := range pq.heap.GetItems() {
		t.Logf("  [%d] %s priority %d", i, task.Value, task.Priority)
	}

	// task2 should now be at the top
	task, err := pq.Pop()
	require.NoError(t, err)
	t.Logf("Popped: %s with priority %d", task.Value, task.Priority)
	require.Equal(t, "task2", task.Value)
	require.Equal(t, 20, task.Priority)
}

func TestPriorityQueue_Update_NotFound(t *testing.T) {
	pq := NewPriorityQueue[string](PriorityCmp[string])

	pq.Insert("task1", 10)
	pq.Insert("task2", 5)

	// Try to update non-existent task
	err := pq.Update("nonexistent", 1)
	require.Equal(t, ErrNotFound, err)
}

func TestPriorityQueue_Update_SamePriority(t *testing.T) {
	pq := NewPriorityQueue[string](PriorityCmp[string])

	pq.Insert("task1", 10)

	// Update with same priority should be no-op
	err := pq.Update("task1", 10)
	require.NoError(t, err)

	// Task should still be there with same priority
	task, err := pq.Pop()
	require.NoError(t, err)
	require.Equal(t, "task1", task.Value)
	require.Equal(t, 10, task.Priority)
}

func TestTask_NewTask(t *testing.T) {
	now := time.Now()
	task := NewTask(5, "test")

	require.Equal(t, 5, task.Priority)
	require.Equal(t, "test", task.Value)
	require.True(t, task.Time.After(now) || task.Time.Equal(now))
}

func TestPriorityCmp(t *testing.T) {
	// Test priority comparison
	task1 := &Task[string]{Priority: 5, Time: time.Now(), Value: "task1"}
	task2 := &Task[string]{Priority: 10, Time: time.Now(), Value: "task2"}

	// Higher priority number should come first (higher priority)
	result := PriorityCmp(task1, task2)
	require.Equal(t, -1, result)

	result = PriorityCmp(task2, task1)
	require.Equal(t, 1, result)

	// Test equal priorities with different times
	time1 := time.Now()
	time2 := time1.Add(time.Second)

	task3 := &Task[string]{Priority: 5, Time: time1, Value: "task3"}
	task4 := &Task[string]{Priority: 5, Time: time2, Value: "task4"}

	// Earlier time should come first when priorities are equal
	result = PriorityCmp(task3, task4)
	require.Equal(t, 1, result)

	result = PriorityCmp(task4, task3)
	require.Equal(t, -1, result)

	// Test completely equal tasks
	task5 := &Task[string]{Priority: 5, Time: time1, Value: "task5"}
	task6 := &Task[string]{Priority: 5, Time: time1, Value: "task6"}

	result = PriorityCmp(task5, task6)
	require.Equal(t, 0, result)
}

func TestPriorityQueue_WithDifferentTypes(t *testing.T) {
	// Test with integer values
	intPQ := NewPriorityQueue[int](PriorityCmp[int])

	intPQ.Insert(100, 3)
	intPQ.Insert(200, 5)
	intPQ.Insert(300, 1)

	// Should pop in priority order (highest priority number first)
	task, err := intPQ.Pop()
	require.NoError(t, err)
	require.Equal(t, 200, task.Value)
	require.Equal(t, 5, task.Priority)

	task, err = intPQ.Pop()
	require.NoError(t, err)
	require.Equal(t, 100, task.Value)
	require.Equal(t, 3, task.Priority)

	task, err = intPQ.Pop()
	require.NoError(t, err)
	require.Equal(t, 300, task.Value)
	require.Equal(t, 1, task.Priority)
}

func TestPriorityQueue_TimeOrdering(t *testing.T) {
	pq := NewPriorityQueue[string](PriorityCmp[string])

	// Insert tasks with same priority but different times
	time1 := time.Now()

	// Insert tasks with slight delays to ensure different timestamps
	task1 := Task[string]{Priority: 5, Time: time1, Value: "first"}
	task2 := Task[string]{Priority: 5, Time: time1.Add(time.Millisecond), Value: "second"}
	task3 := Task[string]{Priority: 5, Time: time1.Add(2 * time.Millisecond), Value: "third"}

	// Insert them manually to control timing
	pq.heap.Insert(task1)
	pq.heap.Insert(task2)
	pq.heap.Insert(task3)

	// Should pop in time order when priorities are equal
	firstTask, err := pq.Pop()
	require.NoError(t, err)
	require.Equal(t, "first", firstTask.Value)

	secondTask, err := pq.Pop()
	require.NoError(t, err)
	require.Equal(t, "second", secondTask.Value)

	thirdTask, err := pq.Pop()
	require.NoError(t, err)
	require.Equal(t, "third", thirdTask.Value)
}

func TestPriorityQueue_LargeDataset(t *testing.T) {
	pq := NewPriorityQueue[int](PriorityCmp[int])

	// Insert many items with random priorities
	priorities := []int{50, 10, 30, 20, 40, 5, 15, 25, 35, 45}
	values := []int{500, 100, 300, 200, 400, 50, 150, 250, 350, 450}

	for i := 0; i < len(priorities); i++ {
		pq.Insert(values[i], priorities[i])
	}

	require.Equal(t, len(priorities), pq.heap.Size())

	// Pop all items and verify they come out in priority order
	var poppedPriorities []int
	for pq.heap.Size() > 0 {
		task, err := pq.Pop()
		require.NoError(t, err)
		poppedPriorities = append(poppedPriorities, task.Priority)
	}

	// Verify priorities are in descending order (highest first)
	for i := 1; i < len(poppedPriorities); i++ {
		require.GreaterOrEqual(t, poppedPriorities[i-1], poppedPriorities[i])
	}
}

func TestPriorityQueue_MultipleUpdates(t *testing.T) {
	pq := NewPriorityQueue[string](PriorityCmp[string])

	// Insert tasks
	pq.Insert("A", 10)
	pq.Insert("B", 20)
	pq.Insert("C", 30)

	// Update priorities multiple times
	err := pq.Update("C", 35) // Move C to highest priority
	require.NoError(t, err)

	err = pq.Update("A", 5) // Move A to lowest priority
	require.NoError(t, err)

	err = pq.Update("B", 25) // Keep B in middle
	require.NoError(t, err)

	// Should pop in order: C(35), B(25), A(5)
	task, err := pq.Pop()
	require.NoError(t, err)
	require.Equal(t, "C", task.Value)
	require.Equal(t, 35, task.Priority)

	task, err = pq.Pop()
	require.NoError(t, err)
	require.Equal(t, "B", task.Value)
	require.Equal(t, 25, task.Priority)

	task, err = pq.Pop()
	require.NoError(t, err)
	require.Equal(t, "A", task.Value)
	require.Equal(t, 5, task.Priority)
}

// Custom type for testing
type Job struct {
	ID   int
	Name string
}

func TestPriorityQueue_CustomType(t *testing.T) {
	pq := NewPriorityQueue[Job](PriorityCmp[Job])

	job1 := Job{ID: 1, Name: "job1"}
	job2 := Job{ID: 2, Name: "job2"}
	job3 := Job{ID: 3, Name: "job3"}

	pq.Insert(job1, 30)
	pq.Insert(job2, 40)
	pq.Insert(job3, 20)

	// Should pop in priority order (highest priority number first)
	task, err := pq.Pop()
	require.NoError(t, err)
	require.Equal(t, job2, task.Value)
	require.Equal(t, 40, task.Priority)

	task, err = pq.Pop()
	require.NoError(t, err)
	require.Equal(t, job1, task.Value)
	require.Equal(t, 30, task.Priority)

	task, err = pq.Pop()
	require.NoError(t, err)
	require.Equal(t, job3, task.Value)
	require.Equal(t, 20, task.Priority)
}

// Benchmark tests
func BenchmarkPriorityQueue_Insert(b *testing.B) {
	pq := NewPriorityQueue[int](PriorityCmp[int])

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		pq.Insert(i, i%100)
	}
}

func BenchmarkPriorityQueue_Pop(b *testing.B) {
	pq := NewPriorityQueue[int](PriorityCmp[int])

	// Pre-populate
	for i := 0; i < b.N; i++ {
		pq.Insert(i, i%100)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := pq.Pop()
		require.NoError(b, err)
	}
}

func BenchmarkPriorityQueue_Update(b *testing.B) {
	pq := NewPriorityQueue[int](PriorityCmp[int])

	// Pre-populate with 1000 items
	for i := 0; i < 1000; i++ {
		pq.Insert(i, i)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Update random items
		item := i % 1000
		newPriority := (i * 17) % 100
		err := pq.Update(item, newPriority)
		require.NoError(b, err)
	}
}
